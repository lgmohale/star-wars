"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const deepmerge = require("deepmerge");
const fs = require("fs");
const Glob = require("glob");
const graphql_1 = require("graphql");
const graphql_tools_1 = require("graphql-tools");
const Kind = require("graphql/language/kinds");
class GraphQLLoaderError extends Error {
    static zeroMatchError(glob) {
        return new GraphQLLoaderError(`The glob pattern "${glob}" has zero matches`);
    }
    constructor(message) {
        super(message);
        this.name = 'GraphQLLoaderError';
    }
}
exports.GraphQLLoaderError = GraphQLLoaderError;
exports.loadSchema = (pattern, callback) => {
    return new Promise((resolve, reject) => {
        exports.loadDocument(pattern)
            .then(graphql_1.buildASTSchema)
            .then((schema) => callback ? callback(null, schema) : resolve(schema))
            .catch((err) => callback ? callback(err, null) : reject(err));
    });
};
exports.loadDocument = (pattern) => getGlob(pattern).then(combineFiles).then(graphql_1.parse);
exports.combineDocuments = (docs) => graphql_1.buildASTSchema(concatAST(docs));
exports.executableSchemaFromModules = (modules) => {
    const promises = convertModulesToPromises(modules);
    return Promise.all(promises).then((gqlModules) => {
        const schema = exports.combineDocuments(gqlModules.map((mod) => mod.document));
        const resolvers = gqlModules.reduce((prev, curr) => deepmerge(prev, curr.resolvers || {}), {});
        graphql_tools_1.addResolveFunctionsToSchema(schema, resolvers);
        return schema;
    }).catch((e) => { throw e; });
};
const convertModulesToPromises = (modules) => {
    return modules.map((mod) => {
        const result = typeof mod === 'function' ? mod() : mod;
        if (result.document) {
            return Promise.resolve(result);
        }
        else {
            return result;
        }
    });
};
const filterDups = (dups, doc, index, orig) => {
    const hasDups = orig.filter((_) => _.name.value === doc.name.value).length > 1;
    const docInDups = dups.find((_) => _.name.value === doc.name.value);
    return hasDups && !docInDups ? dups.concat(doc) : dups;
};
const mergeFields = (allDefs) => (dup) => {
    allDefs.forEach((def) => {
        if (def.name && def.name.value === dup.name.value && def !== dup) {
            dup.fields = dup.fields.concat(def.fields);
        }
    });
    return dup;
};
const mergeOperations = (allDefs) => (dup) => {
    allDefs.forEach((def) => {
        if (def.kind === Kind.SCHEMA_DEFINITION && def !== dup) {
            const findTypes = (opType) => !dup.operationTypes.find((dupType) => dupType.operation === opType.operation);
            const deduped = def.operationTypes.filter(findTypes);
            dup.operationTypes = dup.operationTypes.concat(deduped);
        }
    });
    return dup;
};
const isKind = (kind) => (def) => def.kind === kind;
const filterSchemaAndDups = (dups) => (def) => {
    return def.kind !== Kind.SCHEMA_DEFINITION && !dups.find((_) => _.name.value === def.name.value);
};
const concatAST = (documents) => {
    const allDefs = documents.reduce((defs, doc) => defs.concat(doc.definitions), []);
    const dups = allDefs.filter(isKind(Kind.OBJECT_TYPE_DEFINITION)).reduce(filterDups, []).map(mergeFields(allDefs));
    const schemas = allDefs.filter(isKind(Kind.SCHEMA_DEFINITION)).slice(0, 1).map(mergeOperations(allDefs));
    const definitions = allDefs.filter(filterSchemaAndDups(dups)).concat(schemas, dups);
    return {
        definitions,
        kind: 'Document',
    };
};
const combineFiles = (fileNames) => {
    const promises = fileNames.map(readFile);
    return Promise.all(promises)
        .then((fileContents) => fileContents.join())
        .catch((err) => { throw err; });
};
const getGlob = (pattern) => {
    return new Promise((resolve, reject) => {
        Glob(pattern, (err, files) => {
            if (files.length === 0) {
                reject(GraphQLLoaderError.zeroMatchError(pattern));
            }
            else {
                resolve(files);
            }
        });
    });
};
const readFile = (fileName) => {
    return new Promise((resolve, reject) => {
        fs.readFile(fileName, 'utf8', (err, data) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(data);
            }
        });
    });
};
exports.loadSchema.sync = (pattern) => {
    const fileNames = getGlobSync(pattern);
    const schema = makeSchemaSync(fileNames);
    return graphql_1.buildASTSchema(graphql_1.parse(schema));
};
const getGlobSync = (pattern) => {
    const fileNames = Glob.sync(pattern);
    if (fileNames.length === 0) {
        throw GraphQLLoaderError.zeroMatchError(pattern);
    }
    else {
        return fileNames;
    }
};
const makeSchemaSync = (fileNames) => {
    return fileNames.map(readFileSync).join();
};
const readFileSync = (fileName) => {
    return fs.readFileSync(fileName, 'utf8');
};
//# sourceMappingURL=index.js.map